import { ethers } from 'ethers'
import * as fs from 'fs'

const FUNCTIONS = {}
const DEPENDENCIES_DIR = './node_modules/@mimic-fi'
const DICTIONARY_OUTPUT = './src/permissions/dictionary.ts'

fs.readdirSync(DEPENDENCIES_DIR).forEach((dependency) => {
  const interfacesDir = `${DEPENDENCIES_DIR}/${dependency}/artifacts/contracts/interfaces`
  if (!fs.existsSync(interfacesDir)) return
  fs.readdirSync(interfacesDir).forEach((file) => processInterfaces(`${interfacesDir}/${file}`))
})

writeOutput()

function processInterfaces(path: string): void {
  if (fs.statSync(path).isDirectory())
    return fs.readdirSync(path).forEach((file) => processInterfaces(`${path}/${file}`))

  const data = JSON.parse(fs.readFileSync(path).toString())
  if (!data.abi) return

  const iface = new ethers.utils.Interface(data.abi)
  data.abi
    .filter((input) => input.type === 'function')
    .filter((input) => input.stateMutability === 'nonpayable')
    .forEach((input) => (FUNCTIONS[iface.getSighash(input.name)] = functionDefinition(input.name, input.inputs)))
}

function functionDefinition(name: string, inputs: { type: string; name: string }[]): string {
  const args = inputs.map((input) => `${input.type} ${input.name}`).join(', ')
  return `${name}(${args})`
}

function writeOutput(): void {
  if (fs.existsSync(DICTIONARY_OUTPUT)) fs.unlinkSync(DICTIONARY_OUTPUT)
  const content = `// This file was autogenerated at deployment time

const dictionary = new Map<string, string>()
${Object.entries(FUNCTIONS)
  .map(([selector, name]) => `dictionary.set('${selector}', '${name}')`)
  .join('\n')}
export default dictionary
`
  fs.writeFileSync(DICTIONARY_OUTPUT, `${content}`)
}
